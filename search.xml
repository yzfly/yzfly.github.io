<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FlowNet</title>
      <link href="/2019/11/16/flownet/"/>
      <url>/2019/11/16/flownet/</url>
      
        <content type="html"><![CDATA[<h1 id="flownet"><a class="markdownIt-Anchor" href="#flownet"></a> FlowNet</h1><p>原论文：</p><p><a href="https://arxiv.org/abs/1504.06852" target="_blank" rel="noopener">FlowNet: Learning Optical Flow with Convolutional Networks</a></p><h2 id="论文阅读"><a class="markdownIt-Anchor" href="#论文阅读"></a> 论文阅读</h2><p>​FlowNet 系列有1.0 和 2.0 版本，本次阅读的是最初版本的 FlowNet。其首先采用神经网络对光流进行预测。</p><h3 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h3><p>​CNNs(卷积神经网络) 最近在一系列计算机视觉任务中都取得了巨大的成功，特别是在与识别相关的任务上。然而CNN在光流估计领域却并不成功。在这篇论文中，我们设计了一个合适的网络，能够将光流估计问题作为监督学习任务来处理。我们提出并比较了两种网络架构：一种是通用架构（FlowNetS），另一种网络架构 (FlowNetC) 则包含了 Correlation 层，用于将不同图像位置的特征向量关联到一起。</p><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><p>​卷积神经网络已经成为了计算机视觉领域诸多任务的可选方法。它们经典的应用是在图片分类领域，但是最近的神经网络结构也能够用于像素级的预测，如语义分割和从单张图片中获取深度图。在本文中，我们打算训练端到端的神经网络来从一对图片中预测光流场。</p><p>​光流估计需要精确的逐像素的定位，同时也需要找出两张输入图片之间的联系。**这不仅需要学习图片的特征表示，同时也需要学习如何在两幅图像的不同位置将其匹配。**在这个方面，光流估计与之前的 CNNs 应用有着本质的区别。</p><p>​因为不清楚该任务是否能够使用标准的 CNN 网络结构来完成，我们另外开发了一个具有明确提供匹配功能的相关层的架构。该结构使用端到端的方法训练。其思想是充分利用神经网络的能力来学习到多个尺度和抽象层次上的强特征，并帮助网络基于这些特征找到实际的对应关系。在关联层（correlation layer）之上（或者说之后）的网络层将从这些匹配中学习如何预测光流。令人惊讶的是，使用这种方法来帮助网络学习是不必要的，并且即使是原始网络都能够学会以很好的精确度来预测光流。</p><p>​训练这样一个预测光流的网络需要一个充分的足够大的训练集。虽然数据增强技术的确有效，但现有的光流数据集还是太小，不足以训练出与当前最先进水平相当的网络。众所周知，为现有的真实视频材料获取光流地面真值是很难的。为了获取足够数量的数据，我们选择牺牲图片的真实性（Trading in realism for quantity）。我们生成了一个合成的飞椅数据集，它由来自 Flickr 的随机背景图像组成，我们在上面覆盖了椅子分段图像，这些椅子来自 cvpr2014 的论文 《Seeing 3D chairs: exemplar part-based 2D-3D alignment using a large dataset of CAD models》。飞椅数据集中的数据与现实世界几乎没有共同点，但是我们可以生成自定义属性的任意数量的样例。令人惊讶的是，即使不进行微调，在这些数据上训练得到的 CNN 模型也能够很好的泛化到现实世界的数据集中。</p><p>​<strong>借助于高效的 GPU 实现 CNN，我们的方法快于任何竞争对手。我们的网络即使是在全分辨率的 Sintel dataset 预测光流，也能够达到每秒 10 张图片的速度，在所有实时的算法中取得了当前最佳结果。</strong></p><h3 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h3><p><strong>光流</strong> 自 Horn 和 Schunck 的工作后，<strong>变分方法一直主导着光流估计领域。<strong>后续引入了许多改进方法。最近的研究重点是大位移，并且</strong>组合匹配方法</strong>也已经集成到变分方法之中。称为 DeepMatching 和 DeepFlow 的方法与我们使用稀疏卷积和最大池化将有限元信息从细到粗地聚合起来的工作有关。然而， 它并没有进行任何学习，并且各个参数是人为确定的。后续的称为 EpicFlow 的工作更加强调稀疏匹配的质量，因为DeepMatching 和 DeepFlow 方法得到的匹配只是在尊重图像边界的条件下对稠密光流场的插值。 我们只使用变分方法对卷积神经网络预测的光流进行可选的优化，不需要任何手工设计的方法进行聚类、匹配和插值。</p><p>​在之前已经有许多学者将机器学习的技巧应用到光流估计之中。Sun 等学者研究了光流的统计特性并使用高斯尺度混合学习了正则化器。Rosenbaum等学者使用高斯混合模型模拟光流的局部统计特性。Black 等人计算了流场训练集的主成分。为了估计光流，他们之后估计了这些 “基流”的线性组合的系数。其它的方法训练分类器从许多不同的惯性估计中选择或者获得遮挡概率。</p><p>​现今已经有人构建神经网络使用无监督学习方法来学习视频帧之间的视差或者运动信息。这些模型通常使用多重交互作用来模拟一对图片之间的关系。然后可以从潜在变量中推断得出视差和光流。Taylor 等人使用分解门控受限的玻尔兹曼机来处理该任务。Konda和 Memisevic 使用一种特殊的称为“synchrony autoencoder” 的自编码器。虽然在受控的设置下这些方法效果良好并且能够从视频中学习到对活动识别有用的信息，但在现实视频中，他们无法与经典方法相媲美。</p><h3 id="network-architectures"><a class="markdownIt-Anchor" href="#network-architectures"></a> Network Architectures</h3><p><strong>卷积神经网络</strong> 使用反向传播算法训练的神经网络在大规模图片分类任务上被 Krizhevsky 证明是十分有效的。这导致了将 CNN 应用到各种计算机视觉任务上的工作激增。</p><p>​虽然当前并没有使用 CNNs 来估计光流的工作，但已经有了与神经网络相匹配的研究。Fisher 等人使用经过监督或非监督学习的CNNs 来提取特征表示，并使用欧氏距离来匹配这些特征。Zbontar 和 LeCun 使用孪生网络训练CNN 来预测图像局部区域的相似性。<strong>我们方法与这些方法的一个巨大区别是：这些方法是基于图像局部区域的并且将空间聚合操作留给后处理，本文的网络直接预测完整的光流。</strong></p><p>​CNNs 最近的应用包括语义分割、深度预测、关键点预测和边缘检测。这些任务与光流估计的共同之处是他们都涉及<strong>像素级别预测</strong>。由于我们的网络受到这些逐像素预测任务进步的很大启发，因此我们简要的回顾这些不同的方法。</p><p>​最简单的方法是使用“滑动窗口”的方式来应用卷积神经网络，为每个输入的图像局部区域计算预测输出。该方法在许多任务上效果良好，但也存在缺点：高额的计算成本（即使使用了复用特征图的优化实现）并且每个图像局部的天然缺陷导致无法输出全局属性，如锐边。另一种简单的方法是上采样特征图至理想的全分辨率并且将其叠加到一起，得到连接像素级的特征向量用于预测感兴趣的数据。</p><p>​Eigen 等学者<strong>通过同时输入粗糙的预测值和图片来训练一个额外的网络用于细化粗糙的深度图。<strong>Long 和 Dosovitskiy 等学者迭代的</strong>使用 ’上采样卷积‘ 层来细化粗特征图</strong>。我们的方法整合了上述两项工作的想法。与 Long 等学者不同的是，我们不只是上卷了粗预测结果，同时也上卷了整个粗糙特征图，使得能够将更多的高层信息转化为精细的预测。与 Dosovitskiy 等学者不同，我们将 “上采样卷积”结果与收缩网络的特征拼接在一起使用。</p><p>​众所周知，在拥有足够的标签数据条件下，卷积神经网络十分擅于学习到输入与输出之间的关系。因此我们使用端到端的学习方法来预测光流：使用包含图像对和光流真实值的数据集，我们训练一个神经网络来直接从图片中预测得到 x-y 光流。但什么样的网络架构才能更好的达成目标呢？</p><p>​**一种简单的方法是将输入的图像对叠加到一起，将其直接输入到一个通用的网络中，使网络自行决定如何处理图像对来提取其中的运动信息。**该网络如图 2 所示。我们将只包含卷积层的网络架构称为“FlowNetSimple”.</p><p>​理论上来说，网络足够大的情况下，该网络能够预测光流。然而，我们无法确定局部梯度优化方法如随机梯度下降算法能够使得网络最终收敛到我们想要的状态（局部最优解）。因此，在给定数据和优化技术的情况下，使用手工设计的不那么通用的网络可能会更加有效。</p><p>​**一种直接的方法是为两张图片设计两条独立但等价的处理流，并在之后的处理流程中将其结合到一起，如图 2 所示。在这种架构下，网络被限制为首先生成两幅独立图像的有意义表示，然后在更高的层面组合到一起。**这有点类似与标准的图像匹配流程：首先从图像对的局部区域中提取出特征，然后将这些特征向量组合到一起。然而，在给定两幅图片的特征响应的情况下，网络如何获得响应呢？</p><p>​为了帮助网络进行匹配，我们引入了一种称为“correlation layer”(关联层)的结构来在两幅特征图之间执行图片局部区域的乘法比较。包含了该关联层的‘FlowNetCorr’网络结构如图2下方所示。</p><p>在给定两幅多通道的特征图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup><mo>→</mo><msup><mi mathvariant="double-struck">R</mi><mi>C</mi></msup></mrow><annotation encoding="application/x-tex">f_1, f_2: \R^{2} \rightarrow \R^{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span></span></span></span></span></span></span></span> , 使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">w, h, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span> 来代表他们的宽、高、通道数，我们的关联层让网络比较将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的局部图像与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的局部图像相比较。</p><p>​现在，我们只考虑<strong>两个图像局部区域的单次比较</strong>。特征图1中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处的局部图像与特征图2中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处的局部图像的相关操作定义为：</p>\begin{equation}c\left(\mathbf{x}_{1}, \mathbf{x}_{2}\right)=\sum_{\mathbf{o} \in[-k, k] \times[-k, k]}\left\langle\mathbf{f}_{1}\left(\mathbf{x}_{1}+\mathbf{o}\right), \mathbf{f}_{2}\left(\mathbf{x}_{2}+\mathbf{o}\right)\right\rangle \end{equation}<p>​对于一个方形的大小为K的小图片（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>:</mo><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">K:= 2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）(:= 为定义为的意思)，公式 (1) 等价于神经网络中的卷积中的一步操作，但与将数据与滤波器进行卷积不同，<strong>它是将数据与其它数据进行卷积。因此，这里没有可训练的权重。</strong></p><p>​计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(x_1, x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>⋅</mo><msup><mi>K</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">c\cdot K^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个乘法。比较所有小图片的组合涉及到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>h</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>w</mi><mn>2</mn></msup><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(w\cdot h)\cdot (w \cdot h)=w^2h^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个上述乘法，产生了很大的结果并且导致前向传播和反向传播都十分棘手。<strong>因此，为了降低计算量，我们限制了比较时候的最大位移，同时在两张特征图中引入跨步。</strong></p><p>​给定最大位移为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> , 对于每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的位置我们只在大小为D（D定义为 2d+1） 的领域内计算相关关系 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(x_1, x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，通过限制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 来实现。我们分别使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mi mathvariant="normal">、</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_1 、s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的步长来全局 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">x_1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的邻域量化 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> .</p><p>​理论上， 相关层产生的结果是四维的，**对于每个2D 图片的位置的组合，我们得到一个相关值，即分别包含裁剪后的图像像素值的两个向量的数量积。**实际中，我们使用通道来组织相对位移，这意味着我们得到的输出是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>×</mo><mi>h</mi><mo>×</mo><msup><mi>D</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">w \times h \times D^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> .对于反向传播层，我们相应的实现了对相应的底团的导数。</p><p>​<strong>细化。</strong>  CNNs 擅于通过交错的卷积和池化等操作来从图片中提取高维特征，即<strong>空间收缩特征映射</strong>。**池化是必要的，为了使得网络训练在计算上可行，更基础的是，能够从输入图像区域的中聚合信息。**然而，池化操作导致图像分辨率下降，为了实现密集的像素级的预测，我们需要一种方式来细化得到的粗糙池化表示。</p><p>​我们使用的<strong>细化方法</strong>如图三所示。<strong>主要成分是“上采样”层，包括向上池化（unpooling, 拓展特征图，与池化操作相反）和一个卷积。<strong>这样的层之前已经有学者使用过。为了进行细化，我们对特征图使用上采样卷积，并且将其与</strong>“收缩”部分的网络中响应的特征图中的结果</strong>、和<strong>粗糙的预测光流上采样结果</strong>（如果有预测光流）相<strong>拼接</strong>。通过这种方式，我们既保留了来自粗糙特征图的高层信息也保留了来自低层特征图的详细局部信息。每一个步骤都将两次提高分辨率。我们重复上述操作四次，结果预测光流的分辨率依然小于输入四倍。</p><p>​我们发现从该分辨率进一步细化，与使用计算量更小的<strong>双线性插值算法相比没有显著的提高效果</strong>。<strong>双线性插值算法的结果就是网络最终得到的预测结果。</strong></p><p>​在另一种方案中，与使用双线性插值不同，我们使用来自论文《Large displacement optical flow: descriptor matching in variational motion estimation.》中<strong>无匹配项的变分法</strong>。我们使用4倍下采样分辨率图，然后使用该方案在 20 次迭代后将光流恢复至全分辨率。最终，我们在全分辨率图片上再执行五次迭代。我们另外计算了图片的边界，使用的方法来自论文《》，同时为了考虑检测到的边界我们使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>λ</mi><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha = \exp(-\lambda b(x,y)^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">λ</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  替代了平滑因子，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 是指在对应尺度和像素间重新采样得到的薄边界的强度。这种上采样方法比简单的双线性插值算法计算开销更大，但是能够获得更加平滑和获得子像素级别平滑的光流场。在下文中，我们将使用这种变分方法得到的结果使用后缀“+v” 表示。图 4 中可以看到一个使用变分法得到的例子。</p><h3 id="training-data"><a class="markdownIt-Anchor" href="#training-data"></a> Training Data</h3><p>​与传统方法不同，神经网络需要有数据真值的数据，不仅仅是为了优化几个参数，而是为了从零开始学会执行该任务。通常来说，获得这样的真实值是困难的，因为准确的像素级对应的显示世界场景是不容易确定的。在表1中给出了可用数据集的概述。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/211857/1583143864847-50f3cdd8-c84b-42de-96d2-76c4b96706be.png" alt="" /></p><h4 id="existing-datasets"><a class="markdownIt-Anchor" href="#existing-datasets"></a> Existing Datasets</h4><p>Middlebury 数据集只包含8对图片用于训练，其光流值是使用四种不同的方法生成的。<strong>运动位移很小</strong>，典型小于10像素。</p><p>​KITTI 数据集更大一些（194 对训练图片）并且**包含大位移，但是只包含非常特殊的运动类型。**其地面真实值是通过使用摄像机和3D激光扫描仪同时对真实世界场景进行记录得到的。其假定场景是刚性的，并且运动来自移动的观察者。此外，远距离物体的运动，如天空，无法捕捉，导致了稀疏的光流值。</p><p>​MPI Sintel 数据集从人造场景中获取真实值，并且十分关注现实的图片属性。提供了两种版本：<strong>最终版本包含了运动模糊和大气效应，如雾，而干净的版本则不包含这些影响。<strong>Sintel 数据集是可用的最大的数据集（各个版本都有 1041 对训练图片）并且为</strong>小位移和大位移都提供了地表真实值。</strong></p><h4 id="flying-chairs"><a class="markdownIt-Anchor" href="#flying-chairs"></a> Flying Chairs</h4><p>​Sintel 数据集对于训练大型 CNNs来说还是太小了。为了提供足够的训练数据，我们创造了一个简单的合成数据集，我们将其称为“飞椅”，通过将仿射变换应用到从 Flicker 收集来的图片和一个公开的3D椅子模型得到。我们从 Flicker 检索了 964 张分辨率为1024x768 的图片，各个分类下的图片为：“city”（321），“landscape”（129），和“mountain” (514). 我们将其切割到四个象限，得到512x384 的图片作为背景。作为前景物体，我们将来自论文《Seeing 3d chairs: exemplar part-based 2d-3d alignment using a large dataset of cad models》的多张椅子的图片添加到背景图片中。从原始数据集中，我们移除了十分相似的椅子，得到809种椅子类型，每种椅子有 62 种不同视图。图5 展示了一个例子。</p><p>​为了产生运动，我们**为背景和椅子随机采样仿射变换参数。椅子的变化和背景的变化是相关的，可以理解为相机和物体都进行了运动。**使用变换参数，我们对第二张图片、光流和闭塞区域进行了渲染。</p><p>​<strong>每对图像的参数（数量、类型、尺寸和椅子的初始位置、变换参数）都是随机采样得到的。我们调整了这些参数的随机分布，使结果的位移直方图与Sintel 数据集中的相同。</strong>（细节可以从支撑材料中得知）。使用上述流程，我们生成了 22872 对图片和光流场（我们多次复用了背景图片）的数据集。注意这个大小是随意选取的，理论上可以更大。</p><h4 id="data-augmentation"><a class="markdownIt-Anchor" href="#data-augmentation"></a> Data Augmentation</h4><p>​数据增强是一种广泛使用的用于改善神经网络泛化性能的方法。即使飞椅数据集十分大了，我们发现使用数据增强来避免过拟合仍然是十分重要的。我们在网络训练时使用在线的数据增强。我们使用的几何变换包括：平移、旋转和缩放，以及附加高斯随机噪声、改变亮度、对比度、伽马和颜色。为了比较快，这些操作都是在GPU上执行的。图 5 中给出了一些数据增强的例子。</p><p>​因为我们不仅要<strong>增加图片的多样性，也要增加光流的多样性</strong>，我们对图片对使用了相同的强变换，但另外对图片对进行了较小的相对变换。我们对光流进行相应的调整，对光流从两侧应用单张图片的增强。</p><p>​特别的，我们的x、y平移采样范围为图片宽度的 【-20%， 20%】,旋转角度范围为[-17, 17]，缩放尺度为【0.9， 2.0】，高斯噪声的 sigma 采样范围为 【0， 0.04】，对比度采样范围为 【-0.8， 0.4】，每张图片的乘色变化范围为【0.5,2】，gamma 数值范围为【0.7,1.5】，添加的亮度变化使用sigma为0.2 的高斯函数。</p><h3 id="experiments"><a class="markdownIt-Anchor" href="#experiments"></a> Experiments</h3><p>​我们报告我们的网络在 Sintel、KITTI 和 Middlebury几个数据集, 同时包括我们合成的飞椅数据集上的结果。我们同时也试验了在 Sintel数据集上微调网络以及使用变分方法来细化预测的光流场。此外，相比于其他方法我们报告了网络的运行时间。</p><h4 id="network-and-trainging-details"><a class="markdownIt-Anchor" href="#network-and-trainging-details"></a> Network and Trainging Details</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/211857/1583143741937-72fde948-76e2-4480-929c-38b7c7df071a.png" alt="" /></p><p>​我们网络的确切结构如图2所示。总的来说，我们努力保持不同网络的结构一致性：他们都有9个卷积层，其中6个包含步长为2的最简单形式的池化层，每层后面都使用 ReLU 非线性函数激活。网络不包含全连接层，因此网络输入的图片可以是任意大小的。卷积核大小随着网络深度加深而减小：第一层使用 7x7, 后面两层使用 5x5, 从第四层开始使用 3x3 。特征图的数量随着层数加深而增加，大概是在每个步长为2的网络层后加倍。对于 FlowNetC 中的相关层，我们使用的参数是 k=0, d=20，s1=1, s2=2. 至于训练损失我们使用端点误差（EPE），这是光流估计的标准误差测量方法。它是预测光流与光流真实数值的欧式距离，对所有像素取平均值。</p><p>对于训练 CNNs, 我们使用修改过的 caffe 框架。我们使用 Adam 作为优化方法，因为在我们的任务中它比动量随机梯度下降收敛更快。我们固定Adam 的参数为： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mo>=</mo><mn>0.9</mn><mspace width="1em"/><msub><mi>β</mi><mn>2</mn></msub><mo>=</mo><mn>0.999</mn></mrow><annotation encoding="application/x-tex">\beta_1=0.9 \quad \beta_2=0.999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span> . 因为在某种意义上说，每个像素都是一个训练样本，因此我们使用很小的迷你批量大小为8. 我们从学习率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\lambda =1e-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 开始，在300k 迭代后，每过 100k 循环便将其缩小一半。在 FlowNetS 上，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\lambda =1e-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 我们观察到了梯度爆炸。为了解决该问题，我们使用十分小的学习率开始  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\lambda =1e-6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> ，在10k循环后慢慢的将其增加到  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\lambda =1e-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>  ，然后遵循之前说的流程训练。</p><p>​为了观察训练和微调过程中的过拟合，我们将飞椅数据集分割为 22232 训练和 640张测试例子，将 Sintel 数据集分为 908 用于训练以及 133 用于验证。</p><p>​我们发现在测试时将图片放大有利于改善性能。尽管放大的大小取决于具体的数据集，我们为所有任务上的网络都固定了一次放大大小。对于 FlowNetS 我们没有放大，对于 FlowNetC 我们选择的缩放因子是 1.25.</p><p>​<strong>Fine-tuning.</strong>  我们使用的数据集在<strong>物体类型和运动类型</strong>上都十分特殊。一种标准的解决方案是在目标数据集上微调模型。KITTI 数据集比较小并且只有稀疏的光流真值。因此，我们选择在 Sintel 训练集上微调模型。我们同时使用来自 Clean 和 Final 版本的 Sintel 数据集，使用十分小的学习率  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\lambda =1e-6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>  在几千次迭代微调模型。为了发挥模型最好的性能，在使用验证集确定了最优的迭代次数后，我们使用同样迭代次数在整个训练集上微调模型。在表格中我们使用“+ft” 后缀来标识微调模型。</p><h4 id="results"><a class="markdownIt-Anchor" href="#results"></a> Results</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/211857/1583143786048-fd181261-5480-4f64-ab12-db3f0263ee18.png" alt="" /></p><p>​表格2展示了我们的网络和几种效果良好的算法在公共数据集(Sintel、KITTI， Middlebury)上的 endpoint error(EPE), 也包括在我们的飞椅数据集。另外我们也展示了不同算法在Sintel 数据集上的运行时间。</p><p>​网络是在非现实的飞椅数据集上训练的在真实的光流数据集上也表现良好，击败了著名的 LDOF 算法。在Sintel 数据集上微调后，我们的网络在 Sintel 数据集上能够超越与之竞争的实时算法 EPPM ，同时在 KITTI 上能够快两倍。</p><p><strong>Sintel</strong>  从表2 我们可以看到, 在Sintel Clean 数据集上FlowNetC 网络比 FlowNetS 表现更好，但是在 Sintel Final 数据集上情况则相反。在这个困难的数据集上， FlowNetS+ft+v 甚至可以与 DeepFlow 相提并论。因为平均 endpoint error 通常偏向于过平滑的解，看到我们的方法的定量结果还是十分有趣的。图7展示了两种网络产生的原始预测光流数据（没有进行微调），将之与地表真值与EpicFlow 结果进行对比。该图展示了网络是如何产生在视觉上吸引人但是在endpoint error 上却更差。<strong>仔细观察后发现可能是因为网络产生非平滑的输出，特别是在大面积光滑的背景区域。<strong>这个问题我们可以使用</strong>变分方法细化</strong>来补偿。</p><p><strong>KITTI.</strong>  KITTI 数据集包含了较强的投影变换，这在网络在飞椅数据集上训练时遇到的情况十分不同。再一次，网络的原始输出仍然已经十分良好，额外的微调和变分调整让结果进一步变好。有趣的是，在 Sintel 数据集上的微调改善了网络在 KITTI 上的表现，可能是因为在Sintel 数据集上的图像和运动比飞椅数据集上的更加自然。<strong>FlowNetS 在这个数据集上的表现优于 FlowNetC.</strong></p><p><strong>Flying Chairs.</strong>  我们的网络在飞椅数据集上训练，因此网络被期待在该数据集上表现最好。当训练时，我们预留出一个包含 640 张图片的测试集。表 2 展示了在该测试集上多种算法的结果，图 6 中展示了一些例子。可以看到 FlowNetC 表现超过了 FlowNetS ，网络的表现超过了所有当前最佳算法。另一个有趣的发现是，这是唯一的变分方法细化没有提高网络性能，反而使得结果更差了。显然，<strong>网络已经可以做的比变分细化更好。这也暗示了当使用更加真实的数据集训练时，网络在其他数据集上甚至可能表现更好。</strong></p><p><strong>Timing.</strong>  在表 2 中， 我们展示不同算法每一帧需要的计算时间（按秒计算）。不幸的是，很多算法只提供了在单张 CPU 上的计算时间，我们的 FlowNet 使用的网络层只能在 GPU 上实现。网络的错误率低于当前最佳水平，但是在实时的算法中是最好的。在训练和测试时我们都使用的是 NVIDIA GTX Tian GPU.  DeepFlow 和 EpicFlow 的CPU 计算时间来自论文《Learning hierarchical features for scene labeling》，LDOF 算法的时间是在单张 2.66 GHz 核心的 CPU 计算的。</p><h4 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> Analysis</h4><p><strong>Traing data.</strong>   为了验证我们是否从 使用飞椅数据集而不是 Sintel 数据集 这一决定中从中受益，我们使用 Sintel 数据集训练了一个网络，单独使用了一个验证集来控制性能。感谢积极的数据扩充，即使单独使用 Sintel 也能够很好的学习光流。 当在 Sintel 上测试的时候，在 Sintel 上专门训练的网络的 EPE 比在飞椅数据集训练然后在 Sintel 上微调的网络大约高一个像素。</p><p>​飞椅数据集已经十分大了，所以数据增强还有必要吗？答案是需要，不进行数据增强在飞椅数据集上训练的网络在 Sintel 数据集上测试的结果是 EPE 大概增加了两个像素。</p><p><strong>Comparing the architectures</strong>  在表2中的结果已经可以让我们对我们测试过的两种架构的长处和弱点下一个结论。</p><p>​首先，FlowNetS 比 FlowNetC 在 Sintel Final 数据集上泛化的更好。另一方面，FlowNetC 在飞椅数据集和 Sintel Clean 数据集上比FlowNetS 表现更好。注意飞椅数据集中不像 Sintel Final 中一样包含运动模糊或雾。这些结果暗示即使两个网络的参数数量实际上是相同的，FlowNetC 稍微有一点点对训练数据过拟合。这不意味着网络在记住了训练样本，但是它适应了在训练过程中的展现的数据。虽然在我们设置中这个可能是一个缺点，但是如果具有更好的训练数据，这可以成为一个优点。</p><p>​第二，**FlowNetC 似乎在大位移方面有很多问题。**这可以从上面讨论的 KITTI 结果中看到，同时可以从在 Sintel Final 的详细性能表现中得知（没有在表中展示）。 FlowNetS+ft 达到了一个 s40+ error (有至少有40个像素的位移的像素上的 EPE)  为 43.3px，对于 FlowNetC+ft 这个数值为 48px。一个解释是关联层的最大位移限制导致了不能够预测到更大的运动。这个范围可以以牺牲计算效率来达到。</p><h3 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h3><p>​得益于最近的卷积网络结构设计进展，**我们已经展现了直接从输入的一对图片中预测得到光流是可能的。**有趣的是，训练数据不需要是现实的。人造的飞椅数据集中只包含了合成的刚性物体的仿射运动就足以已以高准确率的性能来对自然场景中的光流进行预测。这证明了我们所展示的网络的泛化性能。在飞椅数据集的测试集上CNNs甚至能够超越当前最佳的如 DeepFlow 和 EpicFlow 的算法。当更多现实的训练数据可用时，网络的表现能够有多好让人期待！</p><h2 id="阅读心得"><a class="markdownIt-Anchor" href="#阅读心得"></a> 阅读心得</h2><p>网络主要可以分为： 传统的特征提取部分，光流所需的两张图片对应关系的提取部分（两张图片也是时序数据，如何使用时序的方法来处理？）</p><ul><li>如何提取两张图片之间的对应关系？训练一个小型的网络来专门提取对应关系？</li><li>金字塔结构提取，进行上采样和下采样，解决大小位移之间估计不准确的问题。</li><li>数据很重要，如何进一步增强数据处理过程</li></ul><h2 id="疑问"><a class="markdownIt-Anchor" href="#疑问"></a> 疑问</h2><ul><li>池化操作降低图像分辨率，是否真的必要？不使用池化操作直接实现端到端的编码解码如何？最大池化等操作使得图像信息丢失较多，是否有必要池化？</li><li>unpooling 是什么？</li><li>EPE 函数能否进行改进？像 Focal Loss?</li><li>为什么放大图片输入网络性能能更好，增加了信息的稀疏性?</li><li>图像的深度信息是什么？如何获得？（cvpr2009）</li></ul>]]></content>
      
      
      <categories>
          
          <category> deeplearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning Optical-Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 折腾记</title>
      <link href="/2018/07/16/win%E5%92%8Clinux%E5%A4%9A%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/07/16/win%E5%92%8Clinux%E5%A4%9A%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>声明：本教程包括本博客所有内容均为笔记性质，非教程性质。禁止任何形式的转载</strong></p><p>近日安装linux和win10双系统，Linux发行版安装过程一路坎坷，因为之前已经安装过ubuntu18.04，听说Manjaro和mint不错，于是开始了自己的Manjaro-&gt; mint-&gt; ubuntu18.04 的作死之旅，最终还是回到了熟悉的ubuntu18.04下面。</p><h1 id="系统引导和grub2"><a class="markdownIt-Anchor" href="#系统引导和grub2"></a> 系统引导和Grub2</h1><p>系统启动时需要引导程序引导，win10和linux双系统的情况下，先安装win10，再安装linux发行版，即可自动使用grub2引导双系统。</p><p>接下来记录下自己安装过的各个linux发行版需要注意的问题</p><h2 id="manjaro"><a class="markdownIt-Anchor" href="#manjaro"></a> Manjaro</h2><ul><li>安装时选择闭源驱动(none free), 否则容易出现兼容问题</li><li>磁盘分区时，必须挂在  /boot/efi 分区到windows的efi分区(本人电脑为sda2) ，无需格式化，保留原来的FAT32文件系统，tags选择eps、boot</li><li>记住自己磁盘分区的顺序以及各个分区位置，出问题好恢复</li></ul><h3 id="manjaro引导"><a class="markdownIt-Anchor" href="#manjaro引导"></a> manjaro引导</h3><p><strong>安装完成后，可能无法进入manjaro，可以尝试以下方法：</strong><br />​<br />​1、进入开机启动项寻找manjaro的启动项，进入manjaro后再修复<br />​2、无法进入manjaro, 进入win10, 以管理员身份运行下面的命令：<br />​$ bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</p><h3 id="grub-rescue"><a class="markdownIt-Anchor" href="#grub-rescue"></a> grub rescue</h3><p>我安装双系统后，又对磁盘进行了操作，导致无法引导进入系统，grub进入 grub rescue模式，以下记录下修复过程,以下方法对 boot未单独分区时无效。</p><pre><code>rescue 模式下使用的命令有限，只有 ls 、set 、insmod、normal等简单命令，如需退出可使用自己电脑的快捷键重启或者强制关机</code></pre><blockquote><p>set  #查看grub信息<br />ls  #列出所有磁盘，接下来寻找自己的boot分区<br />ls (hd0,gpt*)/boot/grub #把*换成数字，不断去试，输出有grub、boot之类的就找到了<br />set prefix=(hd0,gpt6)/boot/grub root=hd0,gpt6<br />insmod nornal<br />normal   #一直未报错即可正常重启</p></blockquote><p>以上方法只是临时的，进入系统后需要修复引导</p><blockquote><p>sudo grub-install /sda5  #此命令记不清了有可能错了，请baidu<br />sudo grub-update   #更新grub信息</p></blockquote><p>ubuntu用户可使用boot-repair软件自动完成</p><blockquote><p>sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update<br />sudo apt-get install -y boot-repair &amp;&amp; boot-repair<br />查找桌面图标启动boot-repair</p></blockquote><p>配置启动项</p><blockquote><p>sudo add-apt-repository ppa:danielrichter2007/grub-customizer<br />sudo apt-get update<br />sudo apt-get install grub-customizer<br />详情请查看如下博客：<br /><a href="https://blog.csdn.net/zero_hzz/article/details/79205422" target="_blank" rel="noopener">ubuntu18.0+win10 grub2修复与启动项管理</a></p></blockquote><h2 id="mint"><a class="markdownIt-Anchor" href="#mint"></a> mint</h2><p>mint是基于ubuntu修改的开箱即用的linux发行版，但是我在安装的时候无法成功安装boot，尝试好几种修复方式未成功，原因至今未明</p><h2 id="kali"><a class="markdownIt-Anchor" href="#kali"></a> kali</h2><p>安装kali后，需要进行一些简单配置来进行使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#系统更新</span><br><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line"></span><br><span class="line">#软件安装</span><br><span class="line">apt install pkg_name -y</span><br><span class="line">apt install .&#x2F;deb_name.deb #或者使用下面的命令</span><br><span class="line">dpkg -i deb_name.deb</span><br><span class="line"></span><br><span class="line">#安装两个字体来兼容windows文件</span><br><span class="line">apt install ttf-mscorefonts-installer #微软字体</span><br><span class="line">apt install fonts-wqy-microhei    #文泉驿微米黑</span><br><span class="line"></span><br><span class="line">#安装kali的所有安全工具</span><br><span class="line">apt install kali-linux-all</span><br><span class="line"></span><br><span class="line">#修复add-apt-repository</span><br><span class="line">sudo apt-get install python3-software-properties</span><br><span class="line">sudo apt-get install apt-file</span><br><span class="line">sudo apt-file update</span><br><span class="line">gedit &#x2F;usr&#x2F;sbin&#x2F;add-apt-repository</span><br><span class="line"></span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">if [ $# -eq 1 ]</span><br><span class="line">NM&#x3D;&#96;uname -a &amp;&amp; date&#96;</span><br><span class="line">NAME&#x3D;&#96;echo $NM | md5sum | cut -f1 -d&quot; &quot;&#96;</span><br><span class="line">then</span><br><span class="line">ppa_name&#x3D;&#96;echo &quot;$1&quot; | cut -d&quot;:&quot; -f2 -s&#96;</span><br><span class="line">if [ -z &quot;$ppa_name&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;PPA name not found&quot;</span><br><span class="line">echo &quot;Utility to add PPA repositories in your debian machine&quot;</span><br><span class="line">echo &quot;$0 ppa:user&#x2F;ppa-name&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;$ppa_name&quot;</span><br><span class="line">echo &quot;deb http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;morphis&#x2F;anbox-support&#x2F;ubuntu artful main&quot; &gt;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">apt-get update &gt;&gt; &#x2F;dev&#x2F;null 2&gt; &#x2F;tmp&#x2F;$&#123;NAME&#125;_apt_add_key.txt</span><br><span class="line">key&#x3D;&#96;cat &#x2F;tmp&#x2F;$&#123;NAME&#125;_apt_add_key.txt | cut -d&quot;:&quot; -f6 | cut -d&quot; &quot; -f3&#96;</span><br><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key</span><br><span class="line">rm -rf &#x2F;tmp&#x2F;$&#123;NAME&#125;_apt_add_key.txt</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">echo &quot;Utility to add PPA repositories in your debian machine&quot;</span><br><span class="line">echo &quot;$0 ppa:user&#x2F;ppa-name&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#安装java</span><br><span class="line">cd &#x2F;usr&#x2F;sbin&#x2F; &amp;&amp; .&#x2F;add-apt-repository ppa:webupd8team&#x2F;java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install java-common oracle-java8-installer</span><br><span class="line">sudo apt-get install oracle-java8-set-default</span><br></pre></td></tr></table></figure><h1 id="ubuntu1804配置"><a class="markdownIt-Anchor" href="#ubuntu1804配置"></a> Ubuntu18.04配置</h1><p>几番折腾，最后还是回到了ubuntu，manjaro虽说省事，但是KDE的桌面环境实在不适合我，manjaro安装的QQ\Tim都无法使用，中文字体问题也是让我烦心，很多软件都没有官方支持，比如SPSS在manjaro下就无法安装，所以换回熟悉稳定的Ubuntu，这里使用的是Ubuntu18.04 64bit</p><h2 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h2><p>copy windows下C盘fonts文件夹，放入ubuntu的 /usr/shar/fonts文件夹中，然后重新生成字体缓存，即可使用</p><blockquote><p>sudo  cp ~/Temp/WinFonts  /usr/share/fonts<br />sudo fc-cache -f -v</p></blockquote><h2 id="安装java"><a class="markdownIt-Anchor" href="#安装java"></a> 安装java</h2><p>首先卸载自带的openjdk，然后下载oracle的jdk8，解压后放入 /usr/local/ 中，最后编辑 /etc/profile文件添加全局变量</p><blockquote><p>sudo apt-get remove openjdk* #卸载自带的openjdk<br />sudo mv jdk8  /usr/local/<br />sudo gedit /etc/profile</p></blockquote><p>添加下面的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#JAVA</span><br><span class="line">export JAVA_HOME&#x3D;&quot;&#x2F;opt&#x2F;jdk1.8.0_172&quot;</span><br><span class="line">CLASSPATH&#x3D;CLASSPATH.:JAVA_HOME&#x2F;lib:JAVA_HOME&#x2F;jre&#x2F;lib</span><br><span class="line">export PATH&#x3D;PATH:JAVA_HOME&#x2F;bin:JAVA_HOME&#x2F;jre&#x2F;bin</span><br></pre></td></tr></table></figure><p>验证安装</p><pre><code>java -version</code></pre><h2 id="桌面图标"><a class="markdownIt-Anchor" href="#桌面图标"></a> 桌面图标</h2><p>gnome桌面的图标文件存放位置一个在： /usr/share/applications</p><p>另外一个在：~/.local/share/applications</p><p>两个桌面图标模板</p><pre><code> [Desktop Entry]Name=TyporaComment=a minimal Markdown.GenericName=Markdown EditorExec=typora %UIcon=typoraType=ApplicationStartupNotify=trueCategories=Office;WordProcessor;MimeType=text/markdown;text/x-markdown;[Desktop Entry]Version=1.0Type=ApplicationName=NetEase Cloud MusicName[zh_CN]=网易云音乐Name[zh_TW]=網易雲音樂Comment=NetEase Cloud MusicComment[zh_CN]=网易云音乐Comment[zh_TW]=網易雲音樂Icon=netease-cloud-musicExec=netease-cloud-music %U --nosanboxCategories=AudioVideo;Player;Terminal=falseStartupNotify=trueStartupWMClass=netease-cloud-musicMimeType=audio/aac;audio/flac;audio/mp3;audio/mp4;audio/mpeg;audio/ogg;audio/x-ape;audio/x-flac;audio/x-mp3;audio/x-mpeg;audio/x-ms-wma;audio/x-vorbis;audio/x-vorbis+ogg;audio/x-wav;</code></pre><h2 id="使用zsh"><a class="markdownIt-Anchor" href="#使用zsh"></a> 使用zsh</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">ZSH</a><br /><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></p><p>1、第一步：安装zsh</p><blockquote><p>sudo apt-get install zsh</p></blockquote><p>2、第二步：安装oh-my-zsh</p><blockquote><p>sudo sh -c “$( sudo wget <a href="https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh</a> -O -)”</p></blockquote><p>3、使用zsh</p><blockquote><p>chsh -s /bin/zsh</p></blockquote><h2 id="安装anaconda"><a class="markdownIt-Anchor" href="#安装anaconda"></a> 安装Anaconda</h2><p>下载下安装文件后进行安装，安装过程中选择修改 bashrc，添加conda命令</p><p>移除清华源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove channels &#39;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;&#39;</span><br></pre></td></tr></table></figure><p>配置中科大源</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></blockquote><p>安装R环境</p><blockquote><p>conda install -c r r-essentials</p></blockquote><p>安装虚拟环境</p><blockquote><p>conda create -n env_name python=3.4</p></blockquote><h2 id="pip使用"><a class="markdownIt-Anchor" href="#pip使用"></a> pip使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生成requirements.txt文件</span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line">安装requirements.txt依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装hexo</h2><p>官网教程：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo</a></p><p><strong>git仓库添加本机指纹</strong></p><blockquote><p>ssh-keygen -t rsa # 一直回车下去，不输入密码<br />cat ~/.ssh/id_rsa.pub</p></blockquote><p>将输出结果复制，进入github，点击头像-&gt; settings -&gt; ssh and keys中添加本机指纹</p><p><strong>安装hexo</strong><br />hexo依赖于git和nodejs，先安装nodejs，然后运行下面的命令安装hexo</p><blockquote><p>npm install -g hexo-cli</p></blockquote><blockquote><p>hexo generate -d  #收集文件并部署<br />报错，完善信息如下<br />git config --global user.email “你的邮箱”<br />git config --global <a href="http://user.name" target="_blank" rel="noopener">user.name</a> “你的名字”</p></blockquote><h2 id="internet"><a class="markdownIt-Anchor" href="#internet"></a> Internet</h2><h3 id="dns刷新"><a class="markdownIt-Anchor" href="#dns刷新"></a> DNS刷新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install nscd</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nscd restart</span><br></pre></td></tr></table></figure><h3 id="ssr"><a class="markdownIt-Anchor" href="#ssr"></a> SSR</h3><p>将下载下来的ssr-manyuser 文件解压后放入 /usr/local/目录下，正确填写 config.json中的配置，将配置copy进shadowsock文件夹，使用如下命令启动：</p><blockquote><p>cd /usr/local/shadowsocksr-manyuser/shadowsocks/<br />python3 <a href="http://local.py" target="_blank" rel="noopener">local.py</a> -d start/stop</p></blockquote><p>设置快捷命令</p><blockquote><p>gedit ~/.bashrc<br />添加下面内容</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias ssr&#x3D;&quot;cd &#x2F;usr&#x2F;local&#x2F;shadowsocksr-manyuser&#x2F;shadowsocks&#x2F; &amp;&amp; python3 local.py -d &quot;</span><br></pre></td></tr></table></figure><h3 id="proxy"><a class="markdownIt-Anchor" href="#proxy"></a> proxy</h3><h4 id="proxychain"><a class="markdownIt-Anchor" href="#proxychain"></a> proxychain</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install privoxy</span><br><span class="line">sudo gedit &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure><p>在文档中搜索“listen-address”（即监听地址），找到如下一行：<code>listen-address localhost:8118</code>  确保它没有被注释（如果这一行有#号，就手动删除）。再查找“forward-socks5t”，找到如下一行：<code>forward-socks5t / 127.0.0.1:1080 .</code> 同样确保它没有被注释。如果没有这一行，就手动添加（注意！句尾那个点 . 是要写的！）。然后保存退出，再执行以下命令启动privoxy：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo privoxy --user privoxy &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure><p>编辑配置文件/etc/profile 设置全局代理如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先进入编辑模式</span><br><span class="line">sudo gedit &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line"># 在末尾添加以下三行：</span><br><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:8118</span><br><span class="line">export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:8118</span><br><span class="line">export ftp_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>或者按照上面的配置在桌面右上角设置网络代理如上</p><h4 id="privoxy"><a class="markdownIt-Anchor" href="#privoxy"></a> privoxy</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains  # 安装proxychains</span><br><span class="line">sudo vi &#x2F;etc&#x2F;proxychains.conf     # 修改配置文件</span><br><span class="line">将最后一行改成:</span><br><span class="line">socks5  127.0.0.1 1080</span><br><span class="line">之后在需要代理的命令前加上 proxychains 即可</span><br></pre></td></tr></table></figure><p><strong>解决Linux下解压zip包后的文件名乱码问题</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip -O cp936 xxx.zip</span><br></pre></td></tr></table></figure><h2 id="ubuntu软件安装"><a class="markdownIt-Anchor" href="#ubuntu软件安装"></a> Ubuntu软件安装</h2><p><strong>软件目录</strong></p><ul><li>VS code：编辑器</li><li>chrome： 登陆账号后会自动同步浏览器设置</li><li>网易云英语： 音乐类软件</li><li>wechat: 微信</li><li>SMplayer 视频播放器</li><li>teamviewer: 远程连接</li><li>pdfmaster: pdf编辑器</li><li>GIMP： 图片编辑器</li></ul><p><strong>较难安装软件</strong></p><ul><li>WPS: 文档编辑器</li><li>sougoupinyin: 搜狗拼音输入法</li><li>ssr: 安装包，网上下载ssr-manyuser文件然后手动配置(先lantern)</li><li>Tim:  社交软件</li><li>proxyee-down: 百度下载神器</li><li>lingo :数学建模</li></ul><p><strong>Flatpak</strong><br />很多包基于Flatpak发布，安装Flatpak环境能够让我们更轻松的安装更多的包<br />参考：<a href="https://flatpak.org/setup/Ubuntu/" target="_blank" rel="noopener">Install Flatpak官方教程</a></p><blockquote><p>sudo add-apt-repository ppa:alexlarsson/flatpak<br />​     sudo apt update<br />​     sudo apt install flatpak<br />sudo apt install gnome-software-plugin-flatpak<br />flatpak remote-add --if-not-exists flathub <a href="https://flathub.org/repo/flathub.flatpakrepo" target="_blank" rel="noopener">https://flathub.org/repo/flathub.flatpakrepo</a></p></blockquote><p>前面几个安装都较为简单，记录下较难软件的安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i pkg.deb #安装软件包命令</span><br><span class="line">sudo apt install -f  #修复破损依赖命令</span><br></pre></td></tr></table></figure><h3 id="wps"><a class="markdownIt-Anchor" href="#wps"></a> WPS</h3><p><strong>参考博客：</strong> <a href="https://blog.csdn.net/gongchenyu/article/details/80500150" target="_blank" rel="noopener">Ubuntu18.04安装wps office</a><br />wps的安装依赖于一个特殊的libpng软件，需先安装，然安装下载的wps-office安装包，最后解决字体问题（字体部分已解决）。</p><blockquote><p>wget <a href="http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.deb" target="_blank" rel="noopener">http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.deb</a><br />sudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.deb<br />sudo dpkg -i wps-office_10.1.0.5707-a21_amd64.deb</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字体问题</span><br><span class="line">https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1eS6xIzo  #下载相关字体，并解压缩</span><br><span class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  &#x2F;usr&#x2F;share&#x2F;fonts</span><br><span class="line">cd &#x2F;usr&#x2F;share&#x2F;fonts &amp;&amp;</span><br><span class="line">sudo mkfontscale &amp;&amp;</span><br><span class="line">sudo mkfontdir &amp;&amp;</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure><h3 id="sogou拼音"><a class="markdownIt-Anchor" href="#sogou拼音"></a> sogou拼音</h3><blockquote><p>sudo apt-get remove ibus   // 卸载ibus<br />sudo apt-get remove scim<br />sudo apt-get autoremove   // 删除依赖包<br />sudo apt-get -f install   // 修正安装过程中出现的依赖性关系</p></blockquote><blockquote><p>sudo apt-get install fcitx-bin<br />sudo apt-get install fcitx-table</p></blockquote><p>接下来安装下载的搜狗拼音包，出现依赖问题使用下面的命令修复</p><blockquote><p>sudo apt install -f<br />fcitx-config-gtk3  # 如果找不到config选项，使用该命令打开fcitx进行配置，若提示该命令不存在，则按提示安装相应包</p></blockquote><h3 id="tim"><a class="markdownIt-Anchor" href="#tim"></a> Tim</h3><p>此处采用AppImage方式安装Tim，较为简单方便</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wine  <span class="comment">#安装最新版wine</span></span><br><span class="line"><span class="built_in">cd</span> /opt/Tim</span><br><span class="line">./TIM-x86_64.AppImage <span class="comment">#运行Tim</span></span><br></pre></td></tr></table></figure><h3 id="imusic"><a class="markdownIt-Anchor" href="#imusic"></a> imusic</h3><p>搜索ieaseMusic安装，下面对desktop文件进行修改，美化客户端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=iMusic</span><br><span class="line">Comment=这应该是最好的网易云音乐播放器了，没有之一，如果有请打醒 🤘</span><br><span class="line">Exec=<span class="string">"/opt/ieaseMusic/ieaseMusic"</span> %U</span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Icon=rhythmbox</span><br><span class="line">Categories=Music;</span><br></pre></td></tr></table></figure><h3 id="ivdeo"><a class="markdownIt-Anchor" href="#ivdeo"></a> ivdeo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name&#x3D;iVideo</span><br><span class="line">Comment&#x3D;A wonderful video player</span><br><span class="line">Exec&#x3D;smplayer %U</span><br><span class="line">Exec&#x3D;&quot;&#x2F;home&#x2F;lyz&#x2F;Apps&#x2F;git-apps&#x2F;ivideo&#x2F;electron-react-boilerplate&quot; %U</span><br><span class="line">Terminal&#x3D;false</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Icon&#x3D;smplayer</span><br><span class="line">Categories&#x3D;Video;</span><br></pre></td></tr></table></figure><p><strong>问题解决</strong>：</p><ul><li><p>TIM-x86_64.AppImage 无法运行，解决办法</p><blockquote><p>sudo chmod a+x TIM-x86_64.AppImage</p></blockquote></li><li><p>Tim启动后无法输入中文</p><blockquote><p>在/etc/environment中加入</p><p>export GTK_IM_MODULE=fcitx</p><p>export QT_IM_MODULE=fcitx</p><p>export XMODIFIERS=<a href="https://github.com/im" target="_blank" rel="noopener">@im</a>=fcitx</p></blockquote></li></ul><h3 id="spss"><a class="markdownIt-Anchor" href="#spss"></a> SPSS</h3><p>下载安装SPSS安装文件后，安装目录为 /opt/IBM/SPSS/Statistics/25<br />复制破解文件 lservrc到 25该目录</p><blockquote><p>/opt/IBM/SPSS/Statistics/25/<br />sudo cp lservrc /opt/IBM/SPSS/Statistics/25/<br />sudo bash <a href="http://open.sh" target="_blank" rel="noopener">open.sh</a> #开始激活，随便填一个邮箱即可<br />cd bin<br />./spssclient  #启动spss</p></blockquote><h3 id="lingo"><a class="markdownIt-Anchor" href="#lingo"></a> lingo</h3><p>下载地址：</p><blockquote><p><a href="https://www.lindo.com/downloads/LINGO-LINUX-64x86-17.0.run" target="_blank" rel="noopener">https://www.lindo.com/downloads/LINGO-LINUX-64x86-17.0.run</a></p></blockquote><p>下载后安装</p><blockquote><p>sudo chmod 755 ./LINGO-LINUX-64x86-17.0.run -v<br />sudo ./LINGO-LINUX-64x86-17.0.run</p></blockquote><h3 id="sublime-text3配置"><a class="markdownIt-Anchor" href="#sublime-text3配置"></a> sublime text3配置</h3><p><a href="https://github.com/lyfeyaj/sublime-text-imfix" target="_blank" rel="noopener">sublime中文问题解决</a><br />gnome下的sublime text3安装好后，配置相应主题即可得到漂亮的界面，但是不支持中文输入，此时需要按如下步骤操作</p><ul><li>官网下载 sublime-text-3压缩包，解压后，命名为 sublime-text放在 /opt/文件夹下</li></ul><blockquote><p>git clone <a href="https://github.com/lyfeyaj/sublime-text-imfix.git" target="_blank" rel="noopener">https://github.com/lyfeyaj/sublime-text-imfix.git</a><br />cd sublime-text-imfix<br />./sublime-imfix</p></blockquote><p>然后将sublime-text-imfix/src中的desktop文件复制到 /usr/share/applications/ 下面，更换原有桌面图标</p><h3 id="vs-code无法启动"><a class="markdownIt-Anchor" href="#vs-code无法启动"></a> VS code无法启动</h3><p>可能是配置文件被加上了root权限，删除即可<br />删除 ～/.config/.code 文件夹</p><p><strong>配置VS code</strong></p><p>选择工作目录，然后进行工作区设置</p><blockquote><p>{</p><pre><code>&quot;python.pythonPath&quot;: &quot;/home/liu/opt/anaconda3/envs/pyplay/bin/python&quot;</code></pre><p>}</p></blockquote><h3 id="typora-修改字体"><a class="markdownIt-Anchor" href="#typora-修改字体"></a> typora 修改字体</h3><p>打开theme主题，修改css文件，在body标签中的font family，将雅黑放最前y</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>,<span class="string">"Open Sans"</span>,<span class="string">"Clear Sans"</span>,<span class="string">"Helvetica Neue"</span>,Helvetica,Arial,sans-serif;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">51</span>, <span class="number">51</span>, <span class="number">51</span>);</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remarkable-修改字体"><a class="markdownIt-Anchor" href="#remarkable-修改字体"></a> remarkable 修改字体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate remarkable</span><br><span class="line">cd &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;remarkable&#x2F;  #remarkable</span><br><span class="line">ls -a </span><br><span class="line">sudo subl styles.py  #use sublime test edit</span><br></pre></td></tr></table></figure><p>ctrl+F查找 font-family字样，添加（Microsoft YaHei）微软雅黑字体</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: "<span class="selector-tag">Microsoft</span> <span class="selector-tag">YaHei</span>","<span class="selector-tag">Open</span> <span class="selector-tag">Sans</span>","<span class="selector-tag">Clear</span> <span class="selector-tag">Sans</span>","<span class="selector-tag">Helvetica</span> <span class="selector-tag">Neue</span>",<span class="selector-tag">Helvetica</span>,<span class="selector-tag">Arial</span>,<span class="selector-tag">sans-serif</span>;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font</span>:<span class="number">16px</span> Microsoft YaHei,Helvetica,Arial,sans-serif;<span class="attribute">line-height</span>:<span class="number">1.4</span>;<span class="attribute">color</span>:<span class="number">#333</span>;<span class="attribute">word-wrap</span>:break-word;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">15px</span>&#125;  <span class="selector-id">#github</span></span><br></pre></td></tr></table></figure><h3 id="proxyee-down"><a class="markdownIt-Anchor" href="#proxyee-down"></a> proxyee-down</h3><p>注意proxyee-down目录最好不要放在需要root权限的目录，此处放在 /usr/local/<br />下载解压之后运行如下命令启动proxyee-down</p><blockquote><p>cd /usr/local/proxyee-down/<br />java -jar proxyee-down.jar</p></blockquote><h2 id="gnome美化"><a class="markdownIt-Anchor" href="#gnome美化"></a> gnome美化</h2><h3 id="修改gdm"><a class="markdownIt-Anchor" href="#修改gdm"></a> 修改gdm</h3><p>在这里仅仅修改登录界面的背景</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;alternatives </span><br><span class="line">cp gdm3.css gdm3.css.bak</span><br><span class="line">sudo vi gdm3.css</span><br><span class="line"></span><br><span class="line">找到lockDialogGroup部分,并替换为下面的内容，url部分修改为自己想要使用的登录图片</span><br><span class="line">(vim编辑器使用 :?string 对字符串进行搜索)</span><br><span class="line">#lockDialogGroup &#123;</span><br><span class="line">  background: #2c001e url(file:&#x2F;&#x2F;&#x2F;usr&#x2F;share&#x2F;backgrounds&#x2F;mypicture.jpg);         </span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position: center; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考教程：</strong>：<a href="https://www.cnblogs.com/feipeng8848/p/8970556.html" target="_blank" rel="noopener">给Ubuntu18.04安装mac os主题</a><br />主题资源：<a href="https://www.gnome-look.org" target="_blank" rel="noopener">gnome主题</a></p><pre><code>/usr/share/themes   #主题文件目录/usr/share/icons      #图标目录https://www.gnome-look.org  #资源网址</code></pre><p>桌面环境为gnome，接下来安装配置gnome环境，使其像 mac一样，首先安装各种插件</p><blockquote><p>sudo apt-get update<br />sudo apt-get install gnome-tweak-tool gnome-shell-extensions<br />sudo apt-get install chrome-gnome-shell #使能够在chrome下直接安装gnome插件</p></blockquote><p>安装user theme、dash to dock两个插件，将下载下来的主题和图标放入系统主题和图标目录即可，注意看是否有多层目录<br />然后在tweak里面设置自己喜欢的主题和图标</p><h3 id="开机动画plymouth-theme"><a class="markdownIt-Anchor" href="#开机动画plymouth-theme"></a> 开机动画(plymouth theme)</h3><p>进入资源网站下载喜欢的开机动画，解压到/usr/share/plymouth/themes/文件夹，然后修改配置文件即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;</span><br><span class="line"></span><br><span class="line">sudo cp &#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;default.plymouth      &#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;default.plymouth.bak</span><br><span class="line"></span><br><span class="line">sudo gedit &#x2F;usr&#x2F;share&#x2F;plymouth&#x2F;themes&#x2F;default.plymouth</span><br></pre></td></tr></table></figure><p>修改[script]中的内容如下即可：</p><pre><code>[Plymouth Theme]Name=Ubuntu LogoDescription=A theme that features a blank background with a logo.ModuleName=script[script]ImageDir=/usr/share/plymouth/themes/Mageia  #修改此处ScriptFile=/usr/share/plymouth/themes/Mageia/mga.script   #修改此处</code></pre><h2 id="grub美化"><a class="markdownIt-Anchor" href="#grub美化"></a> grub美化</h2><p><strong>参考教程</strong>： <a href="https://www.jianshu.com/p/6abe7c02777b" target="_blank" rel="noopener">GRUB2主题包手动安装设置及其简易修改</a></p><p>第一步： 复制GRUB2主题包到/boot/grub/themes</p><p>第二步：修改GRUB配置文件并更新。</p><p>打开/etc/grub.d/00_header文件</p><pre><code>sudo gedit /etc/grub.d/00_header</code></pre><p>在开头注释后添加</p><pre><code>GRUB_THEME=&quot;/boot/grub/themes/Theme_name/theme.txtGRUB_GFXMODE=&quot;1920×1080x32&quot; # 前面两个改成自己的分辨率</code></pre><p>第三步：更新GRUB</p><pre><code>sudo update-grub</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
